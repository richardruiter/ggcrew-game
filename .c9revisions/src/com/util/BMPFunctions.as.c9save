{"ts":1379002618885,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1379002634464,"patch":[[{"diffs":[[1,"/**\n * BMPFunctions\n *\n * BMPFunctions class provides some functions to modify bitmapData.\n *\n * @author: Han Sanghun (http://hangunsworld.com, hanguns@gmail.com)\n * @created: 2007 10 06\n * @last modified: 2008 03 24\n *\n * Modify Histories\n * 2007 10 08: Adds floodFill method.\n * 2007 10 22: Adds addWatermark method.\n * 2008 03 24: Changes package directory.\n */\n \n /*\nLicensed under the MIT License\n\nCopyright (c) 2008 Han Sanghun\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nhttp://hangunsworld.com/code/com/hangunsworld/net/\n*/\n\npackage com.hangunsworld.util{\n\t\n\timport\tflash.display.BitmapData;\n\timport\tflash.display.Sprite;\n\timport\tflash.geom.Matrix;\n\timport\tflash.geom.Rectangle;\n\timport\tflash.geom.Point;\n\t\n\tpublic class BMPFunctions{\n\t\t\n\t\t\n\t\t\n\t\t/**\n\t\t* Flood fills on an image starting at an (x, y) cordinate and filling with a specific color.\n\t\t* The floodFill() method is similar to the paint bucket tool in various paint programs.\n\t\t*\n\t\t* @param bd The BitmapData to modify.\n\t\t* @param x The x cordinate of the image. \n\t\t* @param y The y cordinate of the image.\n\t\t* @param color The color with which flood fills the image.\n\t\t* @param tolerance The similarity of colors. Ranges from 0 to 255. [OPTIONAL]\n\t\t* @param contiguous The continueity of the area to be filled. [OPTIONAL]\n\t\t*\n\t\t* @return A modified BitmapData.\n\t\t*/\n\t\tpublic static function floodFill(bd:BitmapData, x:uint, y:uint, color:uint, tolerance:uint=0, contiguous:Boolean=false):BitmapData{\n\t\t\t// Varlidates the (x, y) cordinates.\n\t\t\tx = Math.min(bd.width-1, x);\n\t\t\ty = Math.min(bd.height-1, y);\n\t\t\t// Validates the tolerance.\n\t\t\ttolerance = Math.max(0, Math.min(255, tolerance));\n\t\t\t\n\t\t\t// Gets the color of the selected point.\n\t\t\tvar targetColor:uint = bd.getPixel32(x, y);\n\t\t\t\n\t\t\tif(contiguous){\n\t\t\t\t// Fills only the connected area.\n\t\t\t\tvar w:uint = bd.width;\n\t\t\t\tvar h:uint = bd.height;\n\t\t\t\t\n\t\t\t\t// Temporary BitmapData\n\t\t\t\tvar temp_bd:BitmapData = new BitmapData(w, h, false, 0x000000);\n\t\t\t\t\n\t\t\t\t// Fills similar pixels with gray.\n\t\t\t\ttemp_bd.lock();\n\t\t\t\tfor(var i:uint=0; i<w; i++){\n\t\t\t\t\tfor(var k:uint=0; k<h; k++){\n\t\t\t\t\t\tvar d:int = BMPFunctions.getColorDifference32(targetColor, bd.getPixel32(i, k));\n\t\t\t\t\t\tif(d <= tolerance){\n\t\t\t\t\t\t\ttemp_bd.setPixel(i, k, 0x333333);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttemp_bd.unlock();\n\t\t\t\t\n\t\t\t\t// Fills the connected area with white.\n\t\t\t\ttemp_bd.floodFill(x, y, 0xFFFFFF);\n\t\t\t\t\n\t\t\t\t// Uese threshold() to get the white pixels only.\n\t\t\t\tvar rect:Rectangle = new Rectangle(0, 0, w, h);\n\t\t\t\tvar pnt:Point = new Point(0, 0);\n\t\t\t\ttemp_bd.threshold(temp_bd, rect, pnt, \"<\", 0xFF666666, 0xFF000000);\n\t\t\t\t\n\t\t\t\t// Gets the colorBoundsRect to minimizes a for loop.\n\t\t\t\trect = temp_bd.getColorBoundsRect(0xFFFFFFFF, 0xFFFFFFFF);\n\t\t\t\tx = rect.x;\n\t\t\t\ty = rect.y;\n\t\t\t\tw = x + rect.width;\n\t\t\t\th = y + rect.height;\n\t\t\t\t\n\t\t\t\t// Modifies the original image.\n\t\t\t\tbd.lock();\n\t\t\t\tfor(i=x; i<w; i++){\n\t\t\t\t\tfor(k=y; k<h; k++){\n\t\t\t\t\t\tif(temp_bd.getPixel(i, k) == 0xFFFFFF){\n\t\t\t\t\t\t\tbd.setPixel32(i, k, color);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbd.unlock();\n\t\t\t}else{\n\t\t\t\t// Fills all pixels similar to the targetColor.\n\t\t\t\tBMPFunctions.replaceColor(bd, targetColor, color, tolerance);\n\t\t\t}// end if else\n\t\t\t\n\t\t\treturn bd;\n\t\t}// end floodFill\n\t\t\n\t\t\n\t\t\n\t\t/**\n\t\t* Replaces colors similar to color c1 with color c2.\n\t\t*\n\t\t* @param bd The BitmapData to modify.\n\t\t* @param c1 The color to be replaced.\n\t\t* @param c2 The color with which replaces c1.\n\t\t* @param tolerance The similarity of colors. Ranges from 0 to 255. [OPTIONAL]\n\t\t*\n\t\t* @return A modified BitmapData.\n\t\t*/\n\t\tpublic static function replaceColor(bd:BitmapData, c1:uint, c2:uint, tolerance:uint=0):BitmapData{\n\t\t\t// Validates the tolerance.\n\t\t\ttolerance = Math.max(0, Math.min(255, tolerance));\n\t\t\t\n\t\t\tbd.lock();\n\t\t\tvar w:uint = bd.width;\n\t\t\tvar h:uint = bd.height;\n\t\t\tfor(var i:uint=0; i<w; i++){\n\t\t\t\tfor(var k:uint=0; k<h; k++){\n\t\t\t\t\tvar d:int = BMPFunctions.getColorDifference32(c1, bd.getPixel32(i, k));\n\t\t\t\t\tif(d <= tolerance){\n\t\t\t\t\t\tbd.setPixel32(i, k, c2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbd.unlock();\n\t\t\t\n\t\t\treturn bd;\n\t\t}// end replaceColor\n\t\t\n\t\t/**\n\t\t* Calculates of the difference of two colors on an RGB basis.\n\t\t*\n\t\t* @param c1 The first color to compare.\n\t\t* @param c2 The second color to compare.\n\t\t*\n\t\t* @return A difference of the two colors.\n\t\t*/\n\t\tpublic static function getColorDifference(c1:uint, c2:uint):int{\n\t\t\tvar r1:int = (c1 & 0x00FF0000) >>> 16;\n\t\t\tvar g1:int = (c1 & 0x0000FF00) >>> 8;\n\t\t\tvar b1:int = (c1 & 0x0000FF);\n\t\t\t\n\t\t\tvar r2:int = (c2 & 0x00FF0000) >>> 16;\n\t\t\tvar g2:int = (c2 & 0x0000FF00) >>> 8;\n\t\t\tvar b2:int = (c2 & 0x0000FF);\n\t\t\t\n\t\t\tvar r:int = Math.pow((r1-r2), 2);\n\t\t\tvar g:int = Math.pow((g1-g2), 2);\n\t\t\tvar b:int = Math.pow((b1-b2), 2);\n\t\t\t\n\t\t\tvar d:int = Math.sqrt(r + g + b);\n\t\t\t\n\t\t\t// Adjusts the range to 0-255.\n\t\t\td = Math.floor(d / 441 * 255);\n\t\t\t\n\t\t\treturn d;\n\t\t}// end getColorDifference\n\t\t\n\t\t/**\n\t\t* Calculates of the difference of two colors on an RGBA basis.\n\t\t*\n\t\t* @param c1 The first color to compare.\n\t\t* @param c2 The second color to compare.\n\t\t*\n\t\t* @return A difference of the two colors.\n\t\t*/\n\t\tpublic static function getColorDifference32(c1:uint, c2:uint):int{\n\t\t\tvar a1:int = (c1 & 0xFF000000) >>> 24;\n\t\t\tvar r1:int = (c1 & 0x00FF0000) >>> 16;\n\t\t\tvar g1:int = (c1 & 0x0000FF00) >>> 8;\n\t\t\tvar b1:int = (c1 & 0x0000FF);\n\t\t\t\n\t\t\tvar a2:int = (c2 & 0xFF000000) >>> 24;\n\t\t\tvar r2:int = (c2 & 0x00FF0000) >>> 16;\n\t\t\tvar g2:int = (c2 & 0x0000FF00) >>> 8;\n\t\t\tvar b2:int = (c2 & 0x0000FF);\n\t\t\t\n\t\t\tvar a:int = Math.pow((a1-a2), 2);\n\t\t\tvar r:int = Math.pow((r1-r2), 2);\n\t\t\tvar g:int = Math.pow((g1-g2), 2);\n\t\t\tvar b:int = Math.pow((b1-b2), 2);\n\t\t\t\n\t\t\tvar d:int = Math.sqrt(a + r + g + b);\n\t\t\t\n\t\t\t// Adjusts the range to 0-255.\n\t\t\td = Math.floor(d / 510 * 255);\n\t\t\t\n\t\t\treturn d;\n\t\t}// end getColorDifference32\n\t\t\n\t\t\n\t\t/**\n\t\t* Applies watermarks to a BitmapData.\n\t\t*\n\t\t* @param bd A BitmapData to modify.\n\t\t* @param wm A BitmapData to be used as a watermark.\n\t\t* @param margin Space between watermarks. [OPTIONAL]\n\t\t* @param offset Offsets of the wartermark. [OPTIONAL]\n\t\t* @param scale Scale of the wartermark. [OPTIONAL]\n\t\t* @param rotation Rotation of the wartermark. [OPTIONAL]\n\t\t* @param alpha Transparency of the wartermark. [OPTIONAL]\n\t\t*\n\t\t* @return A BitmapData composited with watermarks.\n\t\t*/\n\t\tpublic static function addWatermark(bd:BitmapData, wm:BitmapData, margin:uint=0, offset:uint=0, scale:Number=1, rotation:uint=0, alpha:Number=1):BitmapData{\n\t\t\t// Validates parameters\n\t\t\trotation = Math.min(360, rotation);\n\t\t\talpha = Math.min(1, Math.max(0, alpha));\n\t\t\t\n\t\t\t// Watermark with margins.\n\t\t\tvar wm2:BitmapData = new BitmapData(wm.width+margin, wm.height+margin, true, 0x00);\n\t\t\tvar rect:Rectangle = new Rectangle(0, 0, wm.width, wm.height);\n\t\t\tvar pnt:Point = new Point(0, 0);\n\t\t\twm2.copyPixels(wm, rect, pnt);\n\t\t\t\n\t\t\t// Temporary Sprites to fill with watermarks.\n\t\t\tvar sp1:Sprite = new Sprite();\n\t\t\tvar sp2:Sprite = new Sprite();\n\t\t\t\n\t\t\t// Matrix\n\t\t\tvar matrix:Matrix = new flash.geom.Matrix(); \n\t\t\tmatrix.translate(offset, offset);\n\t\t\tmatrix.rotate(rotation / 180 * Math.PI);\n\t\t\tmatrix.scale(scale, scale);\n\t\t\t\n\t\t\t// Fills the temporary Sprites.\n\t\t\tsp2.graphics.beginBitmapFill(wm2, matrix, true, true);\n\t\t\tsp2.graphics.drawRect(0, 0, bd.width, bd.height);\n\t\t\tsp2.graphics.endFill();\n\t\t\t\n\t\t\tsp1.addChild(sp2);\n\t\t\tsp2.alpha = alpha;\n\t\t\t\n\t\t\t// Draws watermarks to the original BitmapData.\n\t\t\tbd.draw(sp1);\n\t\t\t\n\t\t\t// Clears temporary Sprites.\n\t\t\tsp2.graphics.clear();\n\t\t\tsp1.removeChild(sp2);\n\t\t\t\n\t\t\treturn bd;\n\t\t}// end addWatermark\n\n\t\t\n\t}// end class\n\n}// end package"]],"start1":0,"start2":0,"length1":0,"length2":8549}]],"length":8549,"saved":false}
{"ts":1379002640525,"patch":[[{"diffs":[[0,"age com."],[-1,"hangunsworld."],[0,"util{\n\t\n"]],"start1":1518,"start2":1518,"length1":29,"length2":16}]],"length":8536,"saved":false}
{"contributors":[],"silentsave":false,"ts":1379026364098,"patch":[[{"diffs":[[0,"0xFFFFFF"],[1,"FF"],[0,"){\n\t\t\t\t\t"]],"start1":3920,"start2":3920,"length1":16,"length2":18}]],"length":8538,"saved":false}
{"ts":1379026467846,"patch":[[{"diffs":[[0,"0xFFFFFF"],[-1,"FF"],[0,"){\n\t\t\t\t\t"]],"start1":3920,"start2":3920,"length1":18,"length2":16}]],"length":8536,"saved":false}
{"ts":1379026556985,"patch":[[{"diffs":[[0,"FF){\n\t\t\t\t\t\t\t"],[1,"//"],[0,"bd.setPixel3"]],"start1":3926,"start2":3926,"length1":24,"length2":26},{"diffs":[[0,"color);\n"],[1,"\t\t\t\t\t\t\tbd.setPixel32(i, k, 0xFF666666);\n"],[0,"\t\t\t\t\t\t}\n"]],"start1":3960,"start2":3960,"length1":16,"length2":56}]],"length":8578,"saved":false}
{"contributors":[],"silentsave":false,"ts":1379026700782,"patch":[[{"diffs":[[0,"k, 0xFF6"],[-1,"66666"],[1,"2FF3B"],[0,");\n\t\t\t\t\t"]],"start1":3992,"start2":3992,"length1":21,"length2":21}]],"length":8578,"saved":false}
{"contributors":[],"silentsave":false,"ts":1379051795332,"patch":[[{"diffs":[[0,":uint, c"],[-1,"olo"],[1,"l"],[0,"r:uint, "]],"start1":2361,"start2":2361,"length1":19,"length2":17}]],"length":8576,"saved":false}
{"ts":1379051816079,"patch":[[{"diffs":[[0,"\n\t\t\t\t\t\t\t"],[-1,"//"],[0,"bd.setPi"]],"start1":3928,"start2":3928,"length1":18,"length2":16},{"diffs":[[0,"(i, k, c"],[-1,"olo"],[1,"l"],[0,"r);\n\t\t\t\t"]],"start1":3949,"start2":3949,"length1":19,"length2":17},{"diffs":[[0,"k, clr);\n\t\t\t\t\t\t\t"],[1,"//"],[0,"bd.setPixel32(i,"]],"start1":3953,"start2":3953,"length1":32,"length2":34}]],"length":8574,"saved":false}
{"ts":1379051898533,"patch":[[{"diffs":[[0,"Color, c"],[-1,"olo"],[1,"l"],[0,"r, toler"]],"start1":4144,"start2":4144,"length1":19,"length2":17}]],"length":8572,"saved":false}
{"contributors":[],"silentsave":false,"ts":1379063860603,"patch":[[{"diffs":[[0,"r);\n"],[-1,"\t\t\t\t\t\t\t//bd.setPixel32(i, k, 0xFF62FF3B);\n"],[0,"\t\t\t\t"]],"start1":3958,"start2":3958,"length1":50,"length2":8}]],"length":8530,"saved":false}
